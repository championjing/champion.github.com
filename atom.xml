<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那微微的星火 是希望</title>
  
  <subtitle>综合型创新是易实现、容易把握的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.rongzhiweilai.com/"/>
  <updated>2020-08-16T09:49:42.737Z</updated>
  <id>https://github.rongzhiweilai.com/</id>
  
  <author>
    <name>AChampion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>验证自定义java.lang.String加载过程</title>
    <link href="https://github.rongzhiweilai.com/2020/08/15/%E9%AA%8C%E8%AF%81%E8%87%AA%E5%AE%9A%E4%B9%89java-lang-String%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://github.rongzhiweilai.com/2020/08/15/验证自定义java-lang-String加载过程/</id>
    <published>2020-08-15T08:04:07.000Z</published>
    <updated>2020-08-16T09:49:42.737Z</updated>
    
    <content type="html"><![CDATA[<p>前几天听朋友说面试时候被问到，自定义java.lang.String 是否能加载，以及为什么。之前对类加载机制的过程只有浅显的了解，知道双亲委派和安全策略，但纸上得来终觉浅，所以自己动手试一试，并做记录。</p><h2 id="跳过双亲委派加载自定义类"><a href="#跳过双亲委派加载自定义类" class="headerlink" title="跳过双亲委派加载自定义类"></a>跳过双亲委派加载自定义类</h2><ol><li><p>首先自定义一个类加载器（MyFileClassLoader），并随意定义一个类（名为com.example.Demo），用它来验证MyFileClassLoader能够正常工作。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String directory; <span class="comment">// 被加载类所在的目录</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFileClassLoader</span><span class="params">(String directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类全限定名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//把类名转换为目录</span></span><br><span class="line">        String file = directory+ File.separator + name.replace(<span class="string">"."</span>,File.separator) + <span class="string">".class"</span>; <span class="comment">// 把报名中的点替换成斜线</span></span><br><span class="line">        <span class="comment">//构建输入流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">//构建字节输出流</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( (len = in.read(buf)) != -<span class="number">1</span> ) &#123;</span><br><span class="line">            baos.write( buf, <span class="number">0</span>, len );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> data[] = baos.toByteArray();</span><br><span class="line">        baos.close();</span><br><span class="line">        in.close();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> defineClass( name, data, <span class="number">0</span>,data.length );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建com.example.Demo和java.lang.String类的.java文件</p><p><img src="../img/2020-03/demo-java.PNG" alt="demo-java"></p></li></ol><p><img src="../img/2020-03/string-java.PNG" alt="string-java"></p><p>然后需要把这两个类编译出.class文件，编译方法也很简单，可以通过javac xxx.java 就能在相同文件夹下出现对应的xxx.class文件，或者点击IDEA中的Build，就能在项目中出现xxx.class文件。</p><ol start="3"><li>验证自定义的类加载器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException </span>&#123;</span><br><span class="line">    MyFileClassLoader myFileClassLoader = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"D:/code/myjar/out/production/myjar/"</span>);</span><br><span class="line">    Class clazz = myFileClassLoader.findClass(<span class="string">"com.example.Demo"</span>);</span><br><span class="line">    <span class="comment">//Class clazz = myFileClassLoader.findClass("java.lang.String");</span></span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    <span class="keyword">if</span> ( instance <span class="keyword">instanceof</span> String ) &#123;</span><br><span class="line">        System.out.println(<span class="string">"原String"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"新的类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i am demo cu</span><br><span class="line">新的类</span><br><span class="line">com.example.Demo@5ef04b5</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>运行加载java.lang.String，结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.SecurityException: Prohibited package name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:761)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">at com.rzwl.single.server.MyFileClassLoader.findClass(MyFileClassLoader.java:49)</span><br><span class="line">at com.rzwl.single.server.MyFileClassLoader.main(MyFileClassLoader.java:55)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>结果出现禁用包名异常。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>通过直接加载类的方式，能够最快速的对目标类进行加载，但是这个加载过程也是有安全检查的，这个安全检查是在最后一句的defineClass 方法中进行的，所以无法绕开，最终在加载java.lang.String以抛出异常告终。</p><h2 id="通过双亲委派流程加载自定义类"><a href="#通过双亲委派流程加载自定义类" class="headerlink" title="通过双亲委派流程加载自定义类"></a>通过双亲委派流程加载自定义类</h2><p>接下来通过委派机制运行上面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException </span>&#123;</span><br><span class="line">    MyFileClassLoader myFileClassLoader = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"D:/code/myjar/out/production/myjar/"</span>);</span><br><span class="line">    </span><br><span class="line">    Class clazz = myFileClassLoader.loadClass(<span class="string">"com.example.Demo"</span>);</span><br><span class="line">    <span class="comment">//Class clazz = myFileClassLoader.loadClass("java.lang.String");</span></span><br><span class="line">    Object instance = clazz.newInstance();</span><br><span class="line">    <span class="keyword">if</span> ( instance <span class="keyword">instanceof</span> String ) &#123;</span><br><span class="line">        System.out.println(<span class="string">"原String"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"新的类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在运行期间，在MyFileClassLoader::findClass 内打上断点，使用debug方式运行，两次的加载过程都是顺利的，但是在if判断后能够知道，这里加载的java.lang.String是jdk中的String，而并非自定义的String。</p><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>使用loadClass 方式加载程序会进行双亲委派机制，当加载com.example.Demo时，由于父加载器中没有该类，所以最终加载任务落回到自定义的findClass来执行。但，当加载java.lang.String时，由于父类加载器已经有了jdk中的java.lang.String，双亲委派有避免重复的作用，所以不再加载同一限定名类。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以自定义的java.lang.String是不能够被加载的，</p><ul><li>使用委派机制加载时，jvm只加载jdk中的该类，而不再进行自定义代码的加载</li><li>直接加载方式，会被defineClass中的安全检查抛出异常</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天听朋友说面试时候被问到，自定义java.lang.String 是否能加载，以及为什么。之前对类加载机制的过程只有浅显的了解，知道双亲委派和安全策略，但纸上得来终觉浅，所以自己动手试一试，并做记录。&lt;/p&gt;
&lt;h2 id=&quot;跳过双亲委派加载自定义类&quot;&gt;&lt;a href=&quot;#跳过双亲委派加载自定义类&quot; class=&quot;headerlink&quot; title=&quot;跳过双亲委派加载自定义类&quot;&gt;&lt;/a&gt;跳过双亲委派加载自定义类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先自定义一个类加载器（MyFileClassLoader），并随意定义一个类（名为com.example.Demo），用它来验证MyFileClassLoader能够正常工作。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://github.rongzhiweilai.com/tags/java/"/>
    
      <category term="类加载过程" scheme="https://github.rongzhiweilai.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>DispatcherServlet中的两个设计模式（个人理解）</title>
    <link href="https://github.rongzhiweilai.com/2020/07/15/DispatcherServlet%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%EF%BC%89/"/>
    <id>https://github.rongzhiweilai.com/2020/07/15/DispatcherServlet中的两个设计模式（个人理解）/</id>
    <published>2020-07-15T01:14:52.000Z</published>
    <updated>2020-07-19T07:20:29.952Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看Spring Boot源码，对其中的DispatcherServlet产生兴趣，观察了请求到达后，该类如何运行的，以及它的涉及的设计模式，做了一下简单的分析。<br><a id="more"></a><br><img src="\img\2020-02\DispatcherServlet.PNG" alt></p><p>该类的设计，从结构上来看应该是桥接模式。可以看到，在类设计时，不仅是实现了HttpServlet，还实现Spring特性的接口，在扩展功能的过程中不是盲目的使用单个父类继承关系，这种结构符合桥接模式的定义。</p><p><img src="\img\2020-02\FrameworkServlet.PNG" alt></p><p><img src="\img\2020-02\HttpServlet.PNG" alt></p><p>在Spring运行时，将DispatcherServlet实例化，该类具有HttpServlet，处理http请求时，就由DispatcherServlet实例来处理，首先调用了service()方法，该方法的最后实现是在FrameworkServlet中，FrameworkServlet的service方法中有一句super.service()，而父类的HttpServletBean中并没有重写service()，所以进入HttpServlet中的service方法，此时的service方法中，将调用doXXX()方法（例如doGet、doPost等）来处理请求，而这些方法，在该DispatcherServlet实例中有具体的实现，所以将使用实例中的方法，这个过程感觉很像设计模式中的责任链模式（如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推），不过感觉略显牵强。</p><p>下图中是运行过程，下划线表示该类中没有此方法的实现，需要到父类中寻找 &gt;&gt;表示方法间调用</p><p><img src="\img\2020-02\process.PNG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看Spring Boot源码，对其中的DispatcherServlet产生兴趣，观察了请求到达后，该类如何运行的，以及它的涉及的设计模式，做了一下简单的分析。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring" scheme="https://github.rongzhiweilai.com/tags/Spring/"/>
    
      <category term="设计模式" scheme="https://github.rongzhiweilai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序测试账号 不出现appid</title>
    <link href="https://github.rongzhiweilai.com/2020/05/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E8%B4%A6%E5%8F%B7-%E4%B8%8D%E5%87%BA%E7%8E%B0appid/"/>
    <id>https://github.rongzhiweilai.com/2020/05/08/微信小程序测试账号-不出现appid/</id>
    <published>2020-05-08T02:01:46.000Z</published>
    <updated>2020-07-19T05:10:10.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正确解决方法"><a href="#正确解决方法" class="headerlink" title="正确解决方法"></a>正确解决方法</h2><p>不废话，按照以下步骤操作</p><ol><li>登陆微信开发社区 <a href="https://developers.weixin.qq.com/" target="_blank" rel="noopener">https://developers.weixin.qq.com/</a></li><li>登陆微信小程序测试号 <a href="https://developers.weixin.qq.com/" target="_blank" rel="noopener">https://developers.weixin.qq.com/</a></li><li>出现appid</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正确解决方法&quot;&gt;&lt;a href=&quot;#正确解决方法&quot; class=&quot;headerlink&quot; title=&quot;正确解决方法&quot;&gt;&lt;/a&gt;正确解决方法&lt;/h2&gt;&lt;p&gt;不废话，按照以下步骤操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;登陆微信开发社区 &lt;a href=&quot;https://de
      
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="微信小程序" scheme="https://github.rongzhiweilai.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="appid" scheme="https://github.rongzhiweilai.com/tags/appid/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 使用Listener在点击切换状态</title>
    <link href="https://github.rongzhiweilai.com/2020/03/07/Flutter-%E4%BD%BF%E7%94%A8Listener%E5%9C%A8%E7%82%B9%E5%87%BB%E5%88%87%E6%8D%A2%E7%8A%B6%E6%80%81/"/>
    <id>https://github.rongzhiweilai.com/2020/03/07/Flutter-使用Listener在点击切换状态/</id>
    <published>2020-03-07T08:41:07.000Z</published>
    <updated>2020-07-19T05:10:10.543Z</updated>
    
    <content type="html"><![CDATA[<p>通过使用Listener 在 StatefulWidget中实现点击切换状态,下面是实现效果<br><img src="/img/2020-01/flutter.gif" alt></p><a id="more"></a><p>这个组件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class _LikeAndUnlikeState extends State&lt;_LikeAndUnlike&gt; &#123;</span><br><span class="line">  bool _likeFlag = false;</span><br><span class="line">  num _styleId ;</span><br><span class="line">  num _iconSize;</span><br><span class="line">  Widget _icon;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    //从组件中初始化组件状态</span><br><span class="line">    _likeFlag = widget._likeFlag;</span><br><span class="line">    _styleId = widget._styleId;</span><br><span class="line">    _iconSize = widget._iconSize;</span><br><span class="line">    print(&apos;初始like按钮组件&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    String iconPath = &apos;assets/images/like.png&apos;;</span><br><span class="line">    if ( this._likeFlag ) &#123;</span><br><span class="line">      iconPath = &apos;assets/images/like-se.png&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    _icon = Image.asset(</span><br><span class="line">      iconPath,</span><br><span class="line">      height: _iconSize,</span><br><span class="line">      width: _iconSize,</span><br><span class="line">    );</span><br><span class="line">    var listenerIcon = Listener(</span><br><span class="line">      child: _icon,</span><br><span class="line">      onPointerDown: (e)=&gt;&#123;</span><br><span class="line">        _clickChange()</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">    return listenerIcon;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _clickChange()&#123;</span><br><span class="line">    //todo 发送http请求</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _likeFlag = !_likeFlag;</span><br><span class="line">    &#125;);</span><br><span class="line">    print(&apos;点击了喜欢和不喜欢：&apos;+_likeFlag.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过使用Listener 在 StatefulWidget中实现点击切换状态,下面是实现效果&lt;br&gt;&lt;img src=&quot;/img/2020-01/flutter.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://github.rongzhiweilai.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Flutter" scheme="https://github.rongzhiweilai.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>guava中Lists.partition方法分割List源码分析</title>
    <link href="https://github.rongzhiweilai.com/2020/02/20/guava%E4%B8%ADLists-partition%E6%96%B9%E6%B3%95%E5%88%86%E5%89%B2List%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://github.rongzhiweilai.com/2020/02/20/guava中Lists-partition方法分割List源码分析/</id>
    <published>2020-02-20T09:15:38.000Z</published>
    <updated>2020-07-19T05:10:10.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主旨"><a href="#主旨" class="headerlink" title="主旨"></a>主旨</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在对List进行批量操作时，为了控制每次处理List的数据量，通常会将一个大的List进行分割，这时可以用到 com.google.guava 包中的 Lists.partition(List<t> list, int size) 方法。网上也有对这段代码分析的文章，看了几篇之后感觉没有说到重点，所以自己写一篇。</t></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这段源码的重点在于Lists.partition方法返回的是Partition类，这是一个继承自java.util.List的私有类，该方法返回的实例list调用get等方法时的处理，实际是Partition类中覆写的代码来完成的。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><a id="more"></a><p>在分割过程中主要用到的类，关系图如下<br><img src="/img/2020-01/uml.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; partition(List&lt;T&gt; list, int size) &#123;</span><br><span class="line">  checkNotNull(list);</span><br><span class="line">  checkArgument(size &gt; 0);</span><br><span class="line">  return (list instanceof RandomAccess)</span><br><span class="line">      ? new RandomAccessPartition&lt;T&gt;(list, size)</span><br><span class="line">      : new Partition&lt;T&gt;(list, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分割方法会根据传入的list的是否属于RandomAccess，去创建Partition的子类RandomAccessPartition，或者是直接创建Partition类，这里的RandomAccess接口是为了尽可能提高操作效率的一种方式。<br>创建Partition类的构造方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static class Partition&lt;T&gt; extends AbstractList&lt;List&lt;T&gt;&gt; &#123;</span><br><span class="line">  final List&lt;T&gt; list;</span><br><span class="line">  final int size;</span><br><span class="line"></span><br><span class="line">  Partition(List&lt;T&gt; list, int size) &#123;</span><br><span class="line">    this.list = list;</span><br><span class="line">    this.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><p>在使用partition方法返回的List<list> 实例时，调用熟悉的get方法时，实际调用的是Partition类覆写的方法，看一个最常见的get方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override </span><br><span class="line">public List&lt;T&gt; get(int index) &#123;</span><br><span class="line">  checkElementIndex(index, size());</span><br><span class="line">  int start = index * size;</span><br><span class="line">  int end = Math.min(start + size, list.size());</span><br><span class="line">  return list.subList(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></list></p><p>可以看到在调用get方法时，代码将源list进行了分割操作</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; 这种使用private static修改的内部类（static修饰的内部类可以像普通类一样使用，使用它不需要实例一个外部类），很好的保护了代码实现细节，通过重写父类方法实现功能，使代码用起来很方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主旨&quot;&gt;&lt;a href=&quot;#主旨&quot; class=&quot;headerlink&quot; title=&quot;主旨&quot;&gt;&lt;/a&gt;主旨&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在对List进行批量操作时，为了控制每次处理List的数据量，通常会将一个大的List进行分割，这时可以用到 com.google.guava 包中的 Lists.partition(List&lt;t&gt; list, int size) 方法。网上也有对这段代码分析的文章，看了几篇之后感觉没有说到重点，所以自己写一篇。&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这段源码的重点在于Lists.partition方法返回的是Partition类，这是一个继承自java.util.List的私有类，该方法返回的实例list调用get等方法时的处理，实际是Partition类中覆写的代码来完成的。&lt;/p&gt;
&lt;h2 id=&quot;执行流程&quot;&gt;&lt;a href=&quot;#执行流程&quot; class=&quot;headerlink&quot; title=&quot;执行流程&quot;&gt;&lt;/a&gt;执行流程&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="源码分析" scheme="https://github.rongzhiweilai.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序自定义组件与页面值传递过程图解</title>
    <link href="https://github.rongzhiweilai.com/2019/08/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%A1%B5%E9%9D%A2%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3/"/>
    <id>https://github.rongzhiweilai.com/2019/08/01/微信小程序自定义组件与页面值传递过程图解/</id>
    <published>2019-08-01T15:33:18.000Z</published>
    <updated>2020-07-19T05:10:10.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>提取页面公共部分作为自定义组件，本文就组件与页面间的值传递过程用图片方式展示，仅是个人理解，可能存在偏差。</li></ul><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="完成页面传值的步骤："><a href="#完成页面传值的步骤：" class="headerlink" title="完成页面传值的步骤："></a>完成页面传值的步骤：</h3><ol><li><p>定义组件名为comp，写comp.wxml、comp.wxss、comp.js、comp.json，在comp.js中定义属性navbarData数据，comp.wxml中使用数据，wxss文件控制wxml样式，comp.json声明当前内容为Component；</p></li><li><p>创建Page名为pa，首先在pa.json中使用usingComponents定义的组件key作为组件名（相当于变量名）作为nav-bar，value是组件的路径</p></li><li><p>在pa.js中定义data中定义一个数据navbarDataPage，以便传给组件，在pa.wxml中使用nav-bar作为一个标签，并使用属性navbarData，使用navbarDataPage作为值；</p></li><li><p>现在组件中会使用pa.js中定义的navbarDataPage默认值，在pa.js的修改navbarDataPage后使用setData函数，即可传入新值到组件；</p></li></ol><h3 id="图片展示："><a href="#图片展示：" class="headerlink" title="图片展示："></a>图片展示：</h3><p><img src="/img/2019-3/component-page.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;提取页面公共部分作为自定义组件，本文就组件与页面间的值传递过程用图片方式展示，仅是个人理解，可能存在偏差。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="微信小程序" scheme="https://github.rongzhiweilai.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="组件" scheme="https://github.rongzhiweilai.com/tags/%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>springboot jpa druid 动态切换数据源记录</title>
    <link href="https://github.rongzhiweilai.com/2019/07/10/springboot-jpa-druid-%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.rongzhiweilai.com/2019/07/10/springboot-jpa-druid-动态切换数据源记录/</id>
    <published>2019-07-10T12:05:58.000Z</published>
    <updated>2020-07-19T05:10:10.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>大型应用中的读写分离；</li><li>相同业务逻辑，但是对应多个数据库；<a id="more"></a><h2 id="几张非常形象的图片奉上"><a href="#几张非常形象的图片奉上" class="headerlink" title="几张非常形象的图片奉上"></a>几张非常形象的图片奉上</h2></li></ul><ol><li>单一数据库场景</li></ol><ul><li><img src="/img/2019-2/single.jpg" alt></li></ul><ol start="2"><li>多数据库场景</li></ol><ul><li><img src="/img/2019-2/two-data.jpg" alt></li></ul><ol start="3"><li>动态切换</li></ol><ul><li><img src="/img/2019-2/dyna-data.jpg" alt></li></ul><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul><li>步骤</li></ul><ol><li>核心是实现Spring 内置的 AbstractRoutingDataSource 抽象类，实现determineCurrentLookupKey() 方法；</li><li>实例化出多个datasource，并将这些datasource加入到该抽象类中的targetDataSources。</li><li>在操作数据前，dao层会先调用 AbstractRoutingDataSource 抽象类getConnection(),其中的调用的是determineCurrentLookupKey()，获取到对应的datasource；</li><li>借助ThreadLocal保存数据源信息，在整个业务流程中方便获取;</li></ol><ul><li>难点<br>不同连接池实例化事务管理、和生成类似数据库的sessionFactory方法有所不同，可能会费些时间。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><ul><li>springboot版本： 1.5.6.RELEASE</li><li>连接池：alibaba druid</li></ul><h3 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h3><ul><li><p>配置文件, 密码就暴漏吧，哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.test1.url=jdbc:mysql://localhost:3306/multi_test1?characterEncoding=utf8&amp;characterSetResults=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT</span><br><span class="line">spring.datasource.druid.test1.username=root</span><br><span class="line">spring.datasource.druid.test1.password=123456</span><br><span class="line"></span><br><span class="line">spring.datasource.druid.test2.url=jdbc:mysql://localhost:3306/multi_test2?characterEncoding=utf8&amp;characterSetResults=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT</span><br><span class="line">spring.datasource.druid.test2.username=root</span><br><span class="line">spring.datasource.druid.test2.password=123456</span><br><span class="line"></span><br><span class="line">spring.datasource.type = com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">spring.jpa.show-sql=true</span><br><span class="line">spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</span><br></pre></td></tr></table></figure></li><li><p>实现AbstractRoutingDataSource 抽象类</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDataSourceRouter extends AbstractRoutingDataSource &#123;</span><br><span class="line">    </span><br><span class="line">    public static final ThreadLocal&lt;String&gt; dbStore = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">        String dbBean = dbStore.get();</span><br><span class="line">        if(StringUtils.isBlank(dbBean))&#123;</span><br><span class="line">            dbBean = SourceName.TEST1.dbName;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return dbBean;</span><br><span class="line">    &#125;</span><br><span class="line">    enum SourceName&#123;</span><br><span class="line">        TEST1(&quot;test1&quot;),TEST2(&quot;test2&quot;);</span><br><span class="line">        </span><br><span class="line">        public String dbName;</span><br><span class="line">        </span><br><span class="line">        private SourceName(String name)&#123;</span><br><span class="line">            this.dbName = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例化出多个数据源，加入到DynamicDataSourceRouter父类的setTargetDataSources，并设置默认值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class MultiDataConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.datasource.type&#125;&quot;)</span><br><span class="line">    private Class&lt;? extends DataSource&gt; dataSourceType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean(&quot;test1&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource.druid.test1&quot;)</span><br><span class="line">    public DataSource test1()&#123;</span><br><span class="line">        log.info(&quot;构建test1数据源&quot;);</span><br><span class="line">        DataSource source = DataSourceBuilder.create().type(dataSourceType).build();</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;test2&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource.druid.test2&quot;)</span><br><span class="line">    public DataSource test2()&#123;</span><br><span class="line">        log.info(&quot;构建test2--- 数据源&quot;);</span><br><span class="line">        DataSource source = DataSourceBuilder.create().type(dataSourceType).build();</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;routingDataSource&quot;)</span><br><span class="line">    public AbstractRoutingDataSource routingDataSource(@Qualifier(&quot;test1&quot;) DataSource test1,@Qualifier(&quot;test2&quot;) DataSource test2)&#123;</span><br><span class="line">        DynamicDataSourceRouter assistant = new DynamicDataSourceRouter();</span><br><span class="line">        Map&lt;Object, Object&gt; dataSources = new HashMap&lt;&gt;();</span><br><span class="line">        dataSources.put(DynamicDataSourceRouter.SourceName.TEST1.dbName,test1);</span><br><span class="line">        dataSources.put(DynamicDataSourceRouter.SourceName.TEST2.dbName,test2);</span><br><span class="line">        assistant.setDefaultTargetDataSource( test2 );</span><br><span class="line">        assistant.setTargetDataSources(dataSources);</span><br><span class="line">        return assistant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>手动对 Jpa 的 EntityManager 进行初始化和配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(JpaProperties.class)</span><br><span class="line">@EnableJpaRepositories(value = &quot;cn.rzwl.multidata.dao&quot;)</span><br><span class="line">public class JpaEntityManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    @Resource(name = &quot;routingDataSource&quot;)</span><br><span class="line">    private DataSource routingDataSource;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;entityManagerFactoryBean&quot;)</span><br><span class="line">    public LocalContainerEntityManagerFactoryBean entityManagerFactoryBean(EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        // 不明白为什么这里获取不到 application.yml 里的配置</span><br><span class="line">        Map&lt;String, String&gt; properties = jpaProperties.getProperties();</span><br><span class="line">        //要设置这个属性，实现 CamelCase -&gt; UnderScore 的转换</span><br><span class="line">        properties.put(&quot;hibernate.physical_naming_strategy&quot;,</span><br><span class="line">                &quot;org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy&quot;);</span><br><span class="line">        return builder</span><br><span class="line">                .dataSource(routingDataSource)//关键：注入routingDataSource</span><br><span class="line">                .properties(properties)</span><br><span class="line">                .packages(&quot;cn.rzwl.multidata.entity&quot;) //TODO 改成自己的实体类包</span><br><span class="line">                .persistenceUnit(&quot;myPersistenceUnit&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean(name = &quot;entityManagerFactory&quot;)</span><br><span class="line">    public EntityManagerFactory entityManagerFactory(EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return this.entityManagerFactoryBean(builder).getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean(name = &quot;transactionManager&quot;)</span><br><span class="line">    public PlatformTransactionManager transactionManager(EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return new JpaTransactionManager(entityManagerFactory(builder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为方便测试，用filter验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(urlPatterns = &quot;/*&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        log.info(&quot;初始化自定义过滤器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        String site = request.getParameter(&quot;source&quot;);</span><br><span class="line">        if( DynamicDataSourceRouter.SourceName.TEST1.dbName.equals( site ) )&#123;</span><br><span class="line">            DynamicDataSourceRouter.dbStore.set( DynamicDataSourceRouter.SourceName.TEST1.dbName );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            DynamicDataSourceRouter.dbStore.set( DynamicDataSourceRouter.SourceName.TEST2.dbName );</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;进入业务流程&quot;);</span><br><span class="line">        chain.doFilter( request,response );</span><br><span class="line">        log.info(&quot;完成处理&quot;);</span><br><span class="line">        System.out.println(&quot;后续操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址:"></a>源码地址:</h3><p> <a href="https://github.com/championjing/multi-datasource" target="_blank" rel="noopener">点击可看</a> </p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul><li>一个神奇的AbstractRoutingDataSource类，使数据库切换操作举重若轻，优雅得体，告别劳力式编程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大型应用中的读写分离；&lt;/li&gt;
&lt;li&gt;相同业务逻辑，但是对应多个数据库；
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="springboot" scheme="https://github.rongzhiweilai.com/tags/springboot/"/>
    
      <category term="动态切换数据源" scheme="https://github.rongzhiweilai.com/tags/%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    
      <category term="datasource" scheme="https://github.rongzhiweilai.com/tags/datasource/"/>
    
  </entry>
  
  <entry>
    <title>redis session时，sessionId作为token，可靠实现</title>
    <link href="https://github.rongzhiweilai.com/2019/04/19/redis-session%E6%97%B6%EF%BC%8CsessionId%E4%BD%9C%E4%B8%BAtoken%EF%BC%8C%E5%8F%AF%E9%9D%A0%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.rongzhiweilai.com/2019/04/19/redis-session时，sessionId作为token，可靠实现/</id>
    <published>2019-04-19T04:06:01.000Z</published>
    <updated>2020-07-19T05:10:10.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h2><p>在一些不能使用session，或者session不能保持的情况，通常服务器端产生一个token字符串标识用户登录状态。当前端调用后端接口时，将此token作为参数加入到请求中，这样能够避免依赖浏览器与服务端会话状态。token身份验证可用于多域名间保持用户状态，后端负载均衡非ip hash策略等情况。<br><a id="more"></a></p><h2 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h2><ol><li>pom中增加redis和session依赖</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在登陆过程中将用户信息和其他需要的信息放入session</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession httpSession = request.getSession();</span><br><span class="line">httpSession.setAttribute(&quot;user&quot;, user);</span><br></pre></td></tr></table></figure><ol start="3"><li>把sessionId返回给前端</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sessionId = httpSession.getId();</span><br><span class="line">JSONObject result = new JSONObject();</span><br><span class="line">result.put(&quot;sessionId&quot;, sessionId);</span><br></pre></td></tr></table></figure><p>这样的流程就是经常使用session的方式。</p><h2 id="token-sessionId-使用过程-（重点）"><a href="#token-sessionId-使用过程-（重点）" class="headerlink" title="token(sessionId)使用过程 （重点）"></a>token(sessionId)使用过程 <font color="rgb(250, 128, 114)" size="5">（重点）</font></h2><p>重点是从session中获取user的过程，在接收到前端请求时，常见获取user的实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = (User) httpSession.getAttribute(&quot;user&quot;);</span><br></pre></td></tr></table></figure><p>但是这样就没有token什么事了，并没有是使用token来做验证。如果要想使用token（sessionId）获取到user，第一个想法就是直接从使用redisTemplate的hash操作，根据key获取到里面的内容，查看一下redis存储session的key，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a30ffba0ca386f?w=1401&amp;h=272&amp;f=png&amp;s=42478" alt></p><p>这里获取还要注意序列化的问题，只有使用相同方式序列化key后才能获取到值。</p><p>这种方式想想就很复杂，难道没有简洁的方式获取到这些值吗，存进去的时候挺简单，拿出来时候不能这么麻烦吧。本着对spring强大的信心，寻找到了一个bean：<br>RedisOperationsSessionRepository redisOperationsSessionRepository;<br>看到这个类的名字就很亲切，猜想一定它一定能够解决问题。通过自动注入，然后调用方法，得出以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Session session=redisOperationsSessionRepository.findById(sessionId);</span><br><span class="line">if(session==null)&#123;</span><br><span class="line">    throw new ForbidException(&quot;请重新登录&quot;);</span><br><span class="line">&#125;</span><br><span class="line">user=session.getAttribute(&quot;user&quot;);</span><br><span class="line">if(user==null)&#123;</span><br><span class="line">    redisOperationsSessionRepository.deleteById(sessionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的session是org.springframework.session.Session，而不是javax.servlet.http.HttpSession（常用的那个session），但是两者有着密切关系，通过适配器模式，将javax.servlet.http.HttpSession转为org.springframework.session.Session。</p><p>这样就能很方便的通过这个token（sessionId）获取到存储在redis的session的信息。</p><p>这里显然RedisOperationsSessionRepository是解决的关键点，至于是如何找到它，有两种方法：</p><ul><li>第一种，看spring-session-data-redis和spring-session-core源码，找到关键点，这种方法估计会多花3个小时的时间；</li><li>第二种，最简单直接，而且在找到之后再看源码会更清晰，如果感兴趣的话，评论超过5人，我更新文档进行说明，嘎嘎，大神请飘过。</li></ul><p>不足之处请指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景：&quot;&gt;&lt;a href=&quot;#场景：&quot; class=&quot;headerlink&quot; title=&quot;场景：&quot;&gt;&lt;/a&gt;场景：&lt;/h2&gt;&lt;p&gt;在一些不能使用session，或者session不能保持的情况，通常服务器端产生一个token字符串标识用户登录状态。当前端调用后端接口时，将此token作为参数加入到请求中，这样能够避免依赖浏览器与服务端会话状态。token身份验证可用于多域名间保持用户状态，后端负载均衡非ip hash策略等情况。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="https://github.rongzhiweilai.com/tags/redis/"/>
    
      <category term="session" scheme="https://github.rongzhiweilai.com/tags/session/"/>
    
      <category term="token" scheme="https://github.rongzhiweilai.com/tags/token/"/>
    
      <category term="适配器模式" scheme="https://github.rongzhiweilai.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>post请求响应405，两种解决办法</title>
    <link href="https://github.rongzhiweilai.com/2019/03/18/post%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94405%EF%BC%8C%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://github.rongzhiweilai.com/2019/03/18/post请求响应405，两种解决办法/</id>
    <published>2019-03-18T14:56:01.000Z</published>
    <updated>2020-07-19T05:10:10.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>为什么会出现405呢，一般是因为在发送POST请求时，请求路径写错，比如后端接口地址是/api/abc/ 而发送请求时的路径为/api/abc 没有了最后的斜线。</p></li><li><p>这个问题一般通过后端做路径补全解决，如果要求前端每个都严格对上路径格式，那就太难为人了，增加无用工作量。</p></li></ul><a id="more"></a><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>服务端解决有两种方法</li></ul><ol><li>应用服务器层面，通过应用服务器（如nginx）格式化路径；</li><li>应用层面，代码增加过滤器，格式化路径；</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul><li>两种方法的实现</li></ul><ol><li><p>在nginx中可使用rewrite指令，在location中使用if判断uri结尾字符是否为斜杠，若不是，补充斜杠，具体实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /api/&#123;</span><br><span class="line">        if ($request_filename !~  &quot;/$&quot;) &#123;</span><br><span class="line">            rewrite ^(/api/.*) $1/$args?;</span><br><span class="line">        &#125;</span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在应用层（Spring Web实现）增加过滤器，判断uri结尾，需要时补充斜杠，代码如下：</p></li></ol><ul><li><p>定义过滤器逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package default;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : championjing</span><br><span class="line"> * @ClassName: UrlFilter</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Date: 3/1/2019 5:07 PM</span><br><span class="line"> */</span><br><span class="line">public class UrlFilter implements Filter &#123;</span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(UrlFilter.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(javax.servlet.FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpRequest = (HttpServletRequest)request;</span><br><span class="line">        //HttpServletResponseWrapper httpResponse = new HttpServletResponseWrapper((HttpServletResponse) response);</span><br><span class="line">        LOGGER.info(&quot;url:&#123;&#125;&quot;,httpRequest.getRequestURI());</span><br><span class="line">        LOGGER.info(&quot;method:&#123;&#125;&quot;,httpRequest.getMethod());</span><br><span class="line">        LOGGER.info(&quot;content_type:&#123;&#125;&quot;,httpRequest.getHeader(&quot;content-type&quot;));</span><br><span class="line">        LOGGER.info(&quot;cookie:&#123;&#125;&quot;,httpRequest.getHeader(&quot;cookie&quot;));</span><br><span class="line">        LOGGER.info(&quot;param:&#123;&#125;&quot;,httpRequest.getQueryString());</span><br><span class="line">        String path=httpRequest.getRequestURI();</span><br><span class="line">        if(!path.endsWith(&quot;/&quot;))&#123;</span><br><span class="line">            path=path+&quot;/&quot;;</span><br><span class="line">            LOGGER.info(&quot;格式化path:&#123;&#125;&quot;,path);</span><br><span class="line">            httpRequest.getRequestDispatcher(path).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            chain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向Spring容器中加入该过滤器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package default;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : championjing</span><br><span class="line"> * @ClassName: FilterConfig</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Date: 3/1/2019 5:14 PM</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class FilterConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean registFilter() &#123;</span><br><span class="line">        System.out.println(&quot;*******添加过滤器*******&quot;);</span><br><span class="line">        FilterRegistrationBean registration = new FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(new UrlFilter());</span><br><span class="line">        registration.addUrlPatterns(&quot;/wx/*&quot;);</span><br><span class="line">        registration.setName(&quot;UrlFilter&quot;);</span><br><span class="line">        registration.setOrder(1);</span><br><span class="line">        return registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>当post一个并不存在接口时，会返回给405的响应，首先要检查路径是否写错，但极有可能是缺少斜杠问题，这种补全逻辑最好在服务端处理，减少前端失误，让我们一起呵护前端的小伙伴吧！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么会出现405呢，一般是因为在发送POST请求时，请求路径写错，比如后端接口地址是/api/abc/ 而发送请求时的路径为/api/abc 没有了最后的斜线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个问题一般通过后端做路径补全解决，如果要求前端每个都严格对上路径格式，那就太难为人了，增加无用工作量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring" scheme="https://github.rongzhiweilai.com/tags/Spring/"/>
    
      <category term="Java" scheme="https://github.rongzhiweilai.com/tags/Java/"/>
    
      <category term="405" scheme="https://github.rongzhiweilai.com/tags/405/"/>
    
      <category term="Nginx" scheme="https://github.rongzhiweilai.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>处理json参数的注解，更方便的获取请求参数</title>
    <link href="https://github.rongzhiweilai.com/2019/03/07/%E5%A4%84%E7%90%86json%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/"/>
    <id>https://github.rongzhiweilai.com/2019/03/07/处理json参数的注解，更方便的获取请求参数/</id>
    <published>2019-03-07T03:16:22.000Z</published>
    <updated>2020-07-19T05:10:10.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSONParam需求描述"><a href="#JSONParam需求描述" class="headerlink" title="@JSONParam需求描述"></a>@JSONParam需求描述</h2><p>当请求的content-type为application/json时实现一下功能：</p><ol><li>对请求体中的参数做required判断</li><li>解析参数为指定类型</li><li>提供默认值</li></ol><a id="more"></a><h2 id="为什么做-JSONParam（瞎掰）"><a href="#为什么做-JSONParam（瞎掰）" class="headerlink" title="为什么做@JSONParam（瞎掰）"></a>为什么做@JSONParam（瞎掰）</h2><ul><li>自Java5.0版本引入注解之后，各种注解层出不穷。注解的使用让代码简洁优雅，更重要的是，提高代码重用，达到解耦的目的，利于代码的维护和修改。</li></ul><ul><li>对于Web后端框架来说，Spring 相关组件提供了大量注解，提高了开发速度，就拿@RequestParam来说，放在接口方法的参数前，通过几个属性，就能减少很多的参数校验和类型转换操作。</li></ul><ul><li>但是@RequestParam只应用于content-type为application/x-www-form-urlencoded（传统表单方式）的场景，并不适用application/json情况。这时大多会使用@RequestBody代替@RequestParam来获取一个JSON对象（或其他自定义对象），不过对这个JSON对象中的属性和值仍是无感，所以必须在方法体中对这个JSON对象中的属性进行一系列判断。在写这一系列判断时，真是万分感念@RequestParam的贴心与勤劳。</li></ul><ul><li>忍无可忍之下，决定自己动手写一个能够在application/json情况实现@RequestParam类似功能的注解@JSONParam，代码已经提交到github ：<br><a href="https://github.com/championjing/spring-annotation-extension" target="_blank" rel="noopener">https://github.com/championjing/spring-annotation-extension</a><br><a href="https://github.com/championjing/spring-annotation-extension/blob/master/src/main/java/com/rongzhiweilai/extension/annotation/resolver/JSONParamAnnotationResolver.java" target="_blank" rel="noopener">查看具体实现代码</a></li></ul><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><ul><li>每个参数的处理都会请求体中的输入流转为字符串，感觉会有更好的处理方式，但还没想好；</li></ul><h2 id="想要的改进"><a href="#想要的改进" class="headerlink" title="想要的改进"></a>想要的改进</h2><ul><li>name属性可以接受数组，required、defaultValue也接受数组，并与name对应，当返回值类型为JSON时，对这些内容进行一一判断和赋值操作，可避免上面提到的转字符串问题；</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>在pom中添加maven依赖；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.rongzhiweilai.extension&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-annotation-extension&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.1.0-releases&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>Tip: 发布时版本号写的略显随意，实例项目中也需要引入该版本</li></ul><ol start="2"><li><p>将类WebListenerConfiguration加入Spring容器；  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@Import(&#123;com.rongzhiweilai.extension.config.WebListenerConfiguration.class&#125;)</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例项目<br> <a href="https://github.com/championjing/spring-annotation-extension/tree/master/demo" target="_blank" rel="noopener">点击查看示例项目代码</a></p></li></ol><p>希望和大家交流意见，或是推荐已有的实现方案</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSONParam需求描述&quot;&gt;&lt;a href=&quot;#JSONParam需求描述&quot; class=&quot;headerlink&quot; title=&quot;@JSONParam需求描述&quot;&gt;&lt;/a&gt;@JSONParam需求描述&lt;/h2&gt;&lt;p&gt;当请求的content-type为application/json时实现一下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对请求体中的参数做required判断&lt;/li&gt;
&lt;li&gt;解析参数为指定类型&lt;/li&gt;
&lt;li&gt;提供默认值&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring" scheme="https://github.rongzhiweilai.com/tags/Spring/"/>
    
      <category term="Java" scheme="https://github.rongzhiweilai.com/tags/Java/"/>
    
      <category term="JSON" scheme="https://github.rongzhiweilai.com/tags/JSON/"/>
    
      <category term="注解开发" scheme="https://github.rongzhiweilai.com/tags/%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>精简web框架 理解DI、IOC</title>
    <link href="https://github.rongzhiweilai.com/2018/05/15/%E7%B2%BE%E7%AE%80web%E6%A1%86%E6%9E%B6-%E7%90%86%E8%A7%A3DI-IOC/"/>
    <id>https://github.rongzhiweilai.com/2018/05/15/精简web框架-理解DI-IOC/</id>
    <published>2018-05-15T12:48:27.000Z</published>
    <updated>2020-07-19T05:10:10.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说工欲善其事必先利其器，一个优秀的web框架可以说是程序员的利器，Spring框架应是其中牛角，有了它程序员可以更好的关注业务和功能的实现，编码水平瞬间被提升了一个等级，然而在每天使用框架的时候，你是不是会好奇或者迷惑，为什么它能够运行起来？为什么仅是添加一个注解就能够将一个实例赋值给一个被注解的变量？那些听起来高端的概念（如：IOC、DI、AOP等）是如何实现的呢？</p><a id="more"></a><p>本文我们将通过实现一个简单的Java Web框架来理解框架的工作原理和IOC等概念的实现，暂且叫它fine。</p><p>首先给出Java Web框架开发整个流程:</p><p><img src="/images/frame.png" alt="框架流程"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li><p>创建一个maven项目实现fine框架<br> 创建mavne项目添加相关依赖，需要的包大致有：servlet、jsp、jstl、log4j、    mysql、json、    等以及一些工具包，如果你不打算使用视图层可以忽略jsp    和jstl的依赖包。</p></li><li><p>编写加载配置项的工具类ConfigHelper。加一些需要的配置变量。</p></li><li><p>开发类加载器ClassUtil。在程序启动之初加载基础包下所有类。</p></li><li><p>编写注解类，比如@Action（接受http请求的方法）, @Inject（依赖注入）等。注解的概念在书《Java编程思想》中介绍的很清楚，是一种标记，本框架中的注解就是为了在运行中框架能够让程序知道被注解的类、方法或者变量有哪些。</p></li><li><p>实现Bean容器ClassHelper。利用反射机制，将上一步加载的类实例化成对象，并将这些对象放入一个静态的Map&lt;Class&lt;?&gt;,Object&gt;中，此Map就是Bean容器，它记录了类与对象的关系，以后需要单例的对象时就从Bean容器中取出。</p></li><li><p>实现依赖注入，也就是IoC（控制反转），框架来控制对象之间的依赖关系，将一个对象赋值给一个加了相应标记（注解）的变量。具体实现过程是将第4步中的Bean容器（Map&lt;Class&lt;?&gt;,Object&gt;）做遍历操作，查看当前类的成员变量是否带有Inject注解，若带有该注解，就从Bean容器中取出对象，赋值给当前成员变量。</p></li><li><p>实现Controller层，通过一个类ControllerHelper统计请求路径与方法的对应关系。通过反射获取带有@Action注解的方法，获取@Action注解中的请求表达式（请求路径信息），封装一个请求对象（Request）与处理对象（Handler），将Request与Handler建立映射关系，处理请求。</p></li><li><p>实现一个请求转发器，处理所有请求，从HttpServletRequest对象中获取请求路径与参数，将请求路径与ControllerHelper统计的请求路径做对应关系，并将参数传入ControllerHelper中的相应方法。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，一个能够处理http请求的框架终于开发完成，其中还有很多不足之处，但是通过此框架能够深入的理解现在工程中使用的优秀框架的工作原理，有利于我们更好的在实际中排查问题，甚至定义一些特定规则优化现有框架。</p><h2 id="本文参考书籍"><a href="#本文参考书籍" class="headerlink" title="本文参考书籍"></a>本文参考书籍</h2><ul><li>《Java编程思想》</li><li>《Spring源码解析》</li><li>《架构探险 从零开始写javaweb框架》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;话说工欲善其事必先利其器，一个优秀的web框架可以说是程序员的利器，Spring框架应是其中牛角，有了它程序员可以更好的关注业务和功能的实现，编码水平瞬间被提升了一个等级，然而在每天使用框架的时候，你是不是会好奇或者迷惑，为什么它能够运行起来？为什么仅是添加一个注解就能够将一个实例赋值给一个被注解的变量？那些听起来高端的概念（如：IOC、DI、AOP等）是如何实现的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://github.rongzhiweilai.com/tags/Java/"/>
    
      <category term="web 框架" scheme="https://github.rongzhiweilai.com/tags/web-%E6%A1%86%E6%9E%B6/"/>
    
      <category term="DI 依赖注入" scheme="https://github.rongzhiweilai.com/tags/DI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="IOC 控制反转" scheme="https://github.rongzhiweilai.com/tags/IOC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>探究的官方JSON与阿里的fastjson中put操作</title>
    <link href="https://github.rongzhiweilai.com/2017/06/05/%E6%8E%A2%E7%A9%B6%E7%9A%84%E5%AE%98%E6%96%B9JSON%E4%B8%8E%E9%98%BF%E9%87%8C%E7%9A%84fastjson%E4%B8%ADput%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.rongzhiweilai.com/2017/06/05/探究的官方JSON与阿里的fastjson中put操作/</id>
    <published>2017-06-05T06:55:34.000Z</published>
    <updated>2020-07-19T05:10:10.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>首先看两段代码<br>//======================第一段=============================<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.json.JSONObject;</span><br><span class="line">public class JSONTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;key&quot;, &quot;123&quot;);</span><br><span class="line">System.out.println(&quot;#1:&quot;+json.toString());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;#2:&quot;+ new JSONObject().put(&quot;key&quot;, &quot;123&quot;).toString() );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>//============================第二段=======================<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">public class JSONTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;key&quot;, &quot;123&quot;);</span><br><span class="line">System.out.println(&quot;#1:&quot;+json.toString());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;#2:&quot;+ new JSONObject().put(&quot;key&quot;, &quot;123&quot;).toString() );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//===================================================</p><p>很明显的看出这两部分只是引入的jar不同而已。那么运行起来效果能不能一样呢？<br>答案肯定是不同的。<br>首先json.org给出的jar包能够正常运行出你想要的结果，但是fastjson就会给你一些惊喜（自己试一下吧）。<br>为什么会有这种不同呢？</p><h2 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h2><p>一看源码便知。<br>首先json.org实现：<br>public JSONObject put(String key, Object value) throws JSONException {<br>        if (key == null) {<br>            throw new NullPointerException(“Null key.”);<br>        }<br>        if (value != null) {<br>            testValidity(value);<br>            this.map.put(key, value);<br>        } else {<br>            this.remove(key);<br>        }<br>        return this;<br>}<br>这里的put函数会将当前实例返回(return this).所以#2处的连续操作始终是当前实例出来的JSONObject的操作，是没有问题的。<br>再看fastjson中put实现方法：<br>public Object put(String key, Object value) {<br>        return map.put(key, value);<br>}<br>这里返回了map的put方法返回值，下面给出map的put方法实现：</p><pre><code>/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V put(K key, V value) {    if (key == null)        return putForNullKey(value);    int hash = hash(key);    int i = indexFor(hash, table.length);    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }</code></pre><p>当传入的key已经存在时，将返回key对应已有的value，如果key不存在，就会返回null，注释里面说的非常清楚。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以fastjson中的put会依据map中已有的key值来返回不同的值，所以#2中的toString是对key对应的值的操作，但是如果之前key在json中不存在就会变成对null的操作。<br>一点学习经历，不足之处，请多指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;首先看两段代码&lt;br&gt;//======================第一段=============================&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import org.json.JSONObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class JSONTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		JSONObject json = new JSONObject();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		json.put(&amp;quot;key&amp;quot;, &amp;quot;123&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;#1:&amp;quot;+json.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;#2:&amp;quot;+ new JSONObject().put(&amp;quot;key&amp;quot;, &amp;quot;123&amp;quot;).toString() );		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://github.rongzhiweilai.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://github.rongzhiweilai.com/tags/Java/"/>
    
      <category term="JSON" scheme="https://github.rongzhiweilai.com/tags/JSON/"/>
    
      <category term="fastjson" scheme="https://github.rongzhiweilai.com/tags/fastjson/"/>
    
  </entry>
  
</feed>
