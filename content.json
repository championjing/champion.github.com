{"meta":{"title":"那微微的星火 是希望","subtitle":"综合型创新是易实现、容易把握的。","description":"融合智慧 共创未来 冠军","author":"AChampion","url":"https://github.rongzhiweilai.com","root":"/"},"pages":[{"title":"本站介绍","date":"2019-03-05T07:42:36.000Z","updated":"2020-07-19T05:10:10.546Z","comments":true,"path":"about/index.html","permalink":"https://github.rongzhiweilai.com/about/index.html","excerpt":"","text":"技术无涯 学也无涯保持对技术的兴趣，但不沉迷于技术。"},{"title":"categories","date":"2020-07-19T05:10:10.546Z","updated":"2020-07-19T05:10:10.546Z","comments":true,"path":"categories/index.html","permalink":"https://github.rongzhiweilai.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-19T05:10:10.574Z","updated":"2020-07-19T05:10:10.574Z","comments":true,"path":"tags/index.html","permalink":"https://github.rongzhiweilai.com/tags/index.html","excerpt":"","text":""},{"title":"让智慧摩擦出火星子吧","date":"2019-02-05T07:30:07.000Z","updated":"2020-07-19T05:10:10.573Z","comments":true,"path":"links/index.html","permalink":"https://github.rongzhiweilai.com/links/index.html","excerpt":"","text":"友情链接 主题来源 评论支持 恶意链接特别谴责-侵犯原创"}],"posts":[{"title":"验证自定义java.lang.String加载过程","slug":"验证自定义java-lang-String加载过程","date":"2020-08-15T08:04:07.000Z","updated":"2020-08-16T09:49:42.737Z","comments":true,"path":"2020/08/15/验证自定义java-lang-String加载过程/","link":"","permalink":"https://github.rongzhiweilai.com/2020/08/15/验证自定义java-lang-String加载过程/","excerpt":"前几天听朋友说面试时候被问到，自定义java.lang.String 是否能加载，以及为什么。之前对类加载机制的过程只有浅显的了解，知道双亲委派和安全策略，但纸上得来终觉浅，所以自己动手试一试，并做记录。 跳过双亲委派加载自定义类 首先自定义一个类加载器（MyFileClassLoader），并随意定义一个类（名为com.example.Demo），用它来验证MyFileClassLoader能够正常工作。","text":"前几天听朋友说面试时候被问到，自定义java.lang.String 是否能加载，以及为什么。之前对类加载机制的过程只有浅显的了解，知道双亲委派和安全策略，但纸上得来终觉浅，所以自己动手试一试，并做记录。 跳过双亲委派加载自定义类 首先自定义一个类加载器（MyFileClassLoader），并随意定义一个类（名为com.example.Demo），用它来验证MyFileClassLoader能够正常工作。 12345678910111213141516171819202122232425262728293031323334public class MyFileClassLoader extends ClassLoader &#123; private String directory; // 被加载类所在的目录 public MyFileClassLoader(String directory) &#123; this.directory = directory; &#125; /** * * @param name 类全限定名 * @return * @throws ClassNotFoundException */ @SneakyThrows @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; //把类名转换为目录 String file = directory+ File.separator + name.replace(\".\",File.separator) + \".class\"; // 把报名中的点替换成斜线 //构建输入流 InputStream in = new FileInputStream(file); //构建字节输出流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buf = new byte[1024]; int len = -1; while ( (len = in.read(buf)) != -1 ) &#123; baos.write( buf, 0, len ); &#125; byte data[] = baos.toByteArray(); baos.close(); in.close(); return defineClass( name, data, 0,data.length ); &#125;&#125; 新建com.example.Demo和java.lang.String类的.java文件 然后需要把这两个类编译出.class文件，编译方法也很简单，可以通过javac xxx.java 就能在相同文件夹下出现对应的xxx.class文件，或者点击IDEA中的Build，就能在项目中出现xxx.class文件。 验证自定义的类加载器 123456789101112public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException &#123; MyFileClassLoader myFileClassLoader = new MyFileClassLoader(\"D:/code/myjar/out/production/myjar/\"); Class clazz = myFileClassLoader.findClass(\"com.example.Demo\"); //Class clazz = myFileClassLoader.findClass(\"java.lang.String\"); Object instance = clazz.newInstance(); if ( instance instanceof String ) &#123; System.out.println(\"原String\"); &#125; else &#123; System.out.println(\"新的类\"); &#125; System.out.println(instance);&#125; 该输出如下： 12345i am demo cu新的类com.example.Demo@5ef04b5Process finished with exit code 0 运行加载java.lang.String，结果如下: 12345678Exception in thread &quot;main&quot; java.lang.SecurityException: Prohibited package name: java.lang at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662) at java.lang.ClassLoader.defineClass(ClassLoader.java:761) at java.lang.ClassLoader.defineClass(ClassLoader.java:642) at com.rzwl.single.server.MyFileClassLoader.findClass(MyFileClassLoader.java:49) at com.rzwl.single.server.MyFileClassLoader.main(MyFileClassLoader.java:55)Process finished with exit code 1 结果出现禁用包名异常。 原因分析通过直接加载类的方式，能够最快速的对目标类进行加载，但是这个加载过程也是有安全检查的，这个安全检查是在最后一句的defineClass 方法中进行的，所以无法绕开，最终在加载java.lang.String以抛出异常告终。 通过双亲委派流程加载自定义类接下来通过委派机制运行上面代码 12345678910111213public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException &#123; MyFileClassLoader myFileClassLoader = new MyFileClassLoader(\"D:/code/myjar/out/production/myjar/\"); Class clazz = myFileClassLoader.loadClass(\"com.example.Demo\"); //Class clazz = myFileClassLoader.loadClass(\"java.lang.String\"); Object instance = clazz.newInstance(); if ( instance instanceof String ) &#123; System.out.println(\"原String\"); &#125; else &#123; System.out.println(\"新的类\"); &#125; System.out.println(instance);&#125; 如果在运行期间，在MyFileClassLoader::findClass 内打上断点，使用debug方式运行，两次的加载过程都是顺利的，但是在if判断后能够知道，这里加载的java.lang.String是jdk中的String，而并非自定义的String。 原因分析使用loadClass 方式加载程序会进行双亲委派机制，当加载com.example.Demo时，由于父加载器中没有该类，所以最终加载任务落回到自定义的findClass来执行。但，当加载java.lang.String时，由于父类加载器已经有了jdk中的java.lang.String，双亲委派有避免重复的作用，所以不再加载同一限定名类。 结论所以自定义的java.lang.String是不能够被加载的， 使用委派机制加载时，jvm只加载jdk中的该类，而不再进行自定义代码的加载 直接加载方式，会被defineClass中的安全检查抛出异常","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.rongzhiweilai.com/tags/java/"},{"name":"类加载过程","slug":"类加载过程","permalink":"https://github.rongzhiweilai.com/tags/类加载过程/"}]},{"title":"DispatcherServlet中的两个设计模式（个人理解）","slug":"DispatcherServlet中的两个设计模式（个人理解）","date":"2020-07-15T01:14:52.000Z","updated":"2020-07-19T07:20:29.952Z","comments":true,"path":"2020/07/15/DispatcherServlet中的两个设计模式（个人理解）/","link":"","permalink":"https://github.rongzhiweilai.com/2020/07/15/DispatcherServlet中的两个设计模式（个人理解）/","excerpt":"最近在看Spring Boot源码，对其中的DispatcherServlet产生兴趣，观察了请求到达后，该类如何运行的，以及它的涉及的设计模式，做了一下简单的分析。","text":"最近在看Spring Boot源码，对其中的DispatcherServlet产生兴趣，观察了请求到达后，该类如何运行的，以及它的涉及的设计模式，做了一下简单的分析。 该类的设计，从结构上来看应该是桥接模式。可以看到，在类设计时，不仅是实现了HttpServlet，还实现Spring特性的接口，在扩展功能的过程中不是盲目的使用单个父类继承关系，这种结构符合桥接模式的定义。 在Spring运行时，将DispatcherServlet实例化，该类具有HttpServlet，处理http请求时，就由DispatcherServlet实例来处理，首先调用了service()方法，该方法的最后实现是在FrameworkServlet中，FrameworkServlet的service方法中有一句super.service()，而父类的HttpServletBean中并没有重写service()，所以进入HttpServlet中的service方法，此时的service方法中，将调用doXXX()方法（例如doGet、doPost等）来处理请求，而这些方法，在该DispatcherServlet实例中有具体的实现，所以将使用实例中的方法，这个过程感觉很像设计模式中的责任链模式（如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推），不过感觉略显牵强。 下图中是运行过程，下划线表示该类中没有此方法的实现，需要到父类中寻找 &gt;&gt;表示方法间调用","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://github.rongzhiweilai.com/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.rongzhiweilai.com/tags/设计模式/"}]},{"title":"微信小程序测试账号 不出现appid","slug":"微信小程序测试账号-不出现appid","date":"2020-05-08T02:01:46.000Z","updated":"2020-07-19T05:10:10.545Z","comments":true,"path":"2020/05/08/微信小程序测试账号-不出现appid/","link":"","permalink":"https://github.rongzhiweilai.com/2020/05/08/微信小程序测试账号-不出现appid/","excerpt":"","text":"正确解决方法不废话，按照以下步骤操作 登陆微信开发社区 https://developers.weixin.qq.com/ 登陆微信小程序测试号 https://developers.weixin.qq.com/ 出现appid","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://github.rongzhiweilai.com/tags/微信小程序/"},{"name":"appid","slug":"appid","permalink":"https://github.rongzhiweilai.com/tags/appid/"}]},{"title":"Flutter 使用Listener在点击切换状态","slug":"Flutter-使用Listener在点击切换状态","date":"2020-03-07T08:41:07.000Z","updated":"2020-07-19T05:10:10.543Z","comments":true,"path":"2020/03/07/Flutter-使用Listener在点击切换状态/","link":"","permalink":"https://github.rongzhiweilai.com/2020/03/07/Flutter-使用Listener在点击切换状态/","excerpt":"通过使用Listener 在 StatefulWidget中实现点击切换状态,下面是实现效果","text":"通过使用Listener 在 StatefulWidget中实现点击切换状态,下面是实现效果 这个组件的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class _LikeAndUnlikeState extends State&lt;_LikeAndUnlike&gt; &#123; bool _likeFlag = false; num _styleId ; num _iconSize; Widget _icon; @override void initState() &#123; super.initState(); //从组件中初始化组件状态 _likeFlag = widget._likeFlag; _styleId = widget._styleId; _iconSize = widget._iconSize; print(&apos;初始like按钮组件&apos;); &#125; @override Widget build(BuildContext context) &#123; String iconPath = &apos;assets/images/like.png&apos;; if ( this._likeFlag ) &#123; iconPath = &apos;assets/images/like-se.png&apos;; &#125; _icon = Image.asset( iconPath, height: _iconSize, width: _iconSize, ); var listenerIcon = Listener( child: _icon, onPointerDown: (e)=&gt;&#123; _clickChange() &#125;, ); return listenerIcon; &#125; _clickChange()&#123; //todo 发送http请求 setState(() &#123; _likeFlag = !_likeFlag; &#125;); print(&apos;点击了喜欢和不喜欢：&apos;+_likeFlag.toString()); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://github.rongzhiweilai.com/tags/前端/"},{"name":"Flutter","slug":"Flutter","permalink":"https://github.rongzhiweilai.com/tags/Flutter/"}]},{"title":"guava中Lists.partition方法分割List源码分析","slug":"guava中Lists-partition方法分割List源码分析","date":"2020-02-20T09:15:38.000Z","updated":"2020-07-19T05:10:10.543Z","comments":true,"path":"2020/02/20/guava中Lists-partition方法分割List源码分析/","link":"","permalink":"https://github.rongzhiweilai.com/2020/02/20/guava中Lists-partition方法分割List源码分析/","excerpt":"主旨&nbsp;&nbsp;&nbsp;&nbsp;在对List进行批量操作时，为了控制每次处理List的数据量，通常会将一个大的List进行分割，这时可以用到 com.google.guava 包中的 Lists.partition(List list, int size) 方法。网上也有对这段代码分析的文章，看了几篇之后感觉没有说到重点，所以自己写一篇。 &nbsp;&nbsp;&nbsp;&nbsp;这段源码的重点在于Lists.partition方法返回的是Partition类，这是一个继承自java.util.List的私有类，该方法返回的实例list调用get等方法时的处理，实际是Partition类中覆写的代码来完成的。 执行流程","text":"主旨&nbsp;&nbsp;&nbsp;&nbsp;在对List进行批量操作时，为了控制每次处理List的数据量，通常会将一个大的List进行分割，这时可以用到 com.google.guava 包中的 Lists.partition(List list, int size) 方法。网上也有对这段代码分析的文章，看了几篇之后感觉没有说到重点，所以自己写一篇。 &nbsp;&nbsp;&nbsp;&nbsp;这段源码的重点在于Lists.partition方法返回的是Partition类，这是一个继承自java.util.List的私有类，该方法返回的实例list调用get等方法时的处理，实际是Partition类中覆写的代码来完成的。 执行流程 在分割过程中主要用到的类，关系图如下 1234567public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; partition(List&lt;T&gt; list, int size) &#123; checkNotNull(list); checkArgument(size &gt; 0); return (list instanceof RandomAccess) ? new RandomAccessPartition&lt;T&gt;(list, size) : new Partition&lt;T&gt;(list, size);&#125; 分割方法会根据传入的list的是否属于RandomAccess，去创建Partition的子类RandomAccessPartition，或者是直接创建Partition类，这里的RandomAccess接口是为了尽可能提高操作效率的一种方式。创建Partition类的构造方法如下：123456789private static class Partition&lt;T&gt; extends AbstractList&lt;List&lt;T&gt;&gt; &#123; final List&lt;T&gt; list; final int size; Partition(List&lt;T&gt; list, int size) &#123; this.list = list; this.size = size; &#125;…… 在使用partition方法返回的List 实例时，调用熟悉的get方法时，实际调用的是Partition类覆写的方法，看一个最常见的get方法1234567@Override public List&lt;T&gt; get(int index) &#123; checkElementIndex(index, size()); int start = index * size; int end = Math.min(start + size, list.size()); return list.subList(start, end);&#125; 可以看到在调用get方法时，代码将源list进行了分割操作 完结&nbsp;&nbsp;&nbsp;&nbsp; 这种使用private static修改的内部类（static修饰的内部类可以像普通类一样使用，使用它不需要实例一个外部类），很好的保护了代码实现细节，通过重写父类方法实现功能，使代码用起来很方便。","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"https://github.rongzhiweilai.com/tags/源码分析/"}]},{"title":"微信小程序自定义组件与页面值传递过程图解","slug":"微信小程序自定义组件与页面值传递过程图解","date":"2019-08-01T15:33:18.000Z","updated":"2020-07-19T05:10:10.545Z","comments":true,"path":"2019/08/01/微信小程序自定义组件与页面值传递过程图解/","link":"","permalink":"https://github.rongzhiweilai.com/2019/08/01/微信小程序自定义组件与页面值传递过程图解/","excerpt":"前言 提取页面公共部分作为自定义组件，本文就组件与页面间的值传递过程用图片方式展示，仅是个人理解，可能存在偏差。","text":"前言 提取页面公共部分作为自定义组件，本文就组件与页面间的值传递过程用图片方式展示，仅是个人理解，可能存在偏差。 正文完成页面传值的步骤： 定义组件名为comp，写comp.wxml、comp.wxss、comp.js、comp.json，在comp.js中定义属性navbarData数据，comp.wxml中使用数据，wxss文件控制wxml样式，comp.json声明当前内容为Component； 创建Page名为pa，首先在pa.json中使用usingComponents定义的组件key作为组件名（相当于变量名）作为nav-bar，value是组件的路径 在pa.js中定义data中定义一个数据navbarDataPage，以便传给组件，在pa.wxml中使用nav-bar作为一个标签，并使用属性navbarData，使用navbarDataPage作为值； 现在组件中会使用pa.js中定义的navbarDataPage默认值，在pa.js的修改navbarDataPage后使用setData函数，即可传入新值到组件； 图片展示：","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://github.rongzhiweilai.com/tags/微信小程序/"},{"name":"组件","slug":"组件","permalink":"https://github.rongzhiweilai.com/tags/组件/"}]},{"title":"springboot jpa druid 动态切换数据源记录","slug":"springboot-jpa-druid-动态切换数据源记录","date":"2019-07-10T12:05:58.000Z","updated":"2020-07-19T05:10:10.544Z","comments":true,"path":"2019/07/10/springboot-jpa-druid-动态切换数据源记录/","link":"","permalink":"https://github.rongzhiweilai.com/2019/07/10/springboot-jpa-druid-动态切换数据源记录/","excerpt":"场景 大型应用中的读写分离； 相同业务逻辑，但是对应多个数据库；","text":"场景 大型应用中的读写分离； 相同业务逻辑，但是对应多个数据库； 几张非常形象的图片奉上 单一数据库场景 多数据库场景 动态切换 实现方案 步骤 核心是实现Spring 内置的 AbstractRoutingDataSource 抽象类，实现determineCurrentLookupKey() 方法； 实例化出多个datasource，并将这些datasource加入到该抽象类中的targetDataSources。 在操作数据前，dao层会先调用 AbstractRoutingDataSource 抽象类getConnection(),其中的调用的是determineCurrentLookupKey()，获取到对应的datasource； 借助ThreadLocal保存数据源信息，在整个业务流程中方便获取; 难点不同连接池实例化事务管理、和生成类似数据库的sessionFactory方法有所不同，可能会费些时间。 代码实现环境介绍 springboot版本： 1.5.6.RELEASE 连接池：alibaba druid 部分代码 配置文件, 密码就暴漏吧，哈哈 123456789101112spring.datasource.druid.test1.url=jdbc:mysql://localhost:3306/multi_test1?characterEncoding=utf8&amp;characterSetResults=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMTspring.datasource.druid.test1.username=rootspring.datasource.druid.test1.password=123456spring.datasource.druid.test2.url=jdbc:mysql://localhost:3306/multi_test2?characterEncoding=utf8&amp;characterSetResults=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMTspring.datasource.druid.test2.username=rootspring.datasource.druid.test2.password=123456spring.datasource.type = com.alibaba.druid.pool.DruidDataSourcespring.jpa.show-sql=truespring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy 实现AbstractRoutingDataSource 抽象类 123456789101112131415161718192021222324public class DynamicDataSourceRouter extends AbstractRoutingDataSource &#123; public static final ThreadLocal&lt;String&gt; dbStore = new ThreadLocal&lt;&gt;(); @Override protected Object determineCurrentLookupKey() &#123; String dbBean = dbStore.get(); if(StringUtils.isBlank(dbBean))&#123; dbBean = SourceName.TEST1.dbName; &#125; else &#123; &#125; return dbBean; &#125; enum SourceName&#123; TEST1(&quot;test1&quot;),TEST2(&quot;test2&quot;); public String dbName; private SourceName(String name)&#123; this.dbName = name; &#125; &#125;&#125; 实例化出多个数据源，加入到DynamicDataSourceRouter父类的setTargetDataSources，并设置默认值 123456789101112131415161718192021222324252627282930313233343536@Configuration@Slf4jpublic class MultiDataConfig &#123; @Value(&quot;$&#123;spring.datasource.type&#125;&quot;) private Class&lt;? extends DataSource&gt; dataSourceType; @Bean(&quot;test1&quot;) @Primary @ConfigurationProperties(prefix = &quot;spring.datasource.druid.test1&quot;) public DataSource test1()&#123; log.info(&quot;构建test1数据源&quot;); DataSource source = DataSourceBuilder.create().type(dataSourceType).build(); return source; &#125; @Bean(&quot;test2&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.druid.test2&quot;) public DataSource test2()&#123; log.info(&quot;构建test2--- 数据源&quot;); DataSource source = DataSourceBuilder.create().type(dataSourceType).build(); return source; &#125; @Bean(&quot;routingDataSource&quot;) public AbstractRoutingDataSource routingDataSource(@Qualifier(&quot;test1&quot;) DataSource test1,@Qualifier(&quot;test2&quot;) DataSource test2)&#123; DynamicDataSourceRouter assistant = new DynamicDataSourceRouter(); Map&lt;Object, Object&gt; dataSources = new HashMap&lt;&gt;(); dataSources.put(DynamicDataSourceRouter.SourceName.TEST1.dbName,test1); dataSources.put(DynamicDataSourceRouter.SourceName.TEST2.dbName,test2); assistant.setDefaultTargetDataSource( test2 ); assistant.setTargetDataSources(dataSources); return assistant; &#125;&#125; 手动对 Jpa 的 EntityManager 进行初始化和配置 123456789101112131415161718192021222324252627282930313233343536373839 */@Configuration@EnableConfigurationProperties(JpaProperties.class)@EnableJpaRepositories(value = &quot;cn.rzwl.multidata.dao&quot;)public class JpaEntityManager &#123; @Autowired private JpaProperties jpaProperties; @Resource(name = &quot;routingDataSource&quot;) private DataSource routingDataSource; @Bean(name = &quot;entityManagerFactoryBean&quot;) public LocalContainerEntityManagerFactoryBean entityManagerFactoryBean(EntityManagerFactoryBuilder builder) &#123; // 不明白为什么这里获取不到 application.yml 里的配置 Map&lt;String, String&gt; properties = jpaProperties.getProperties(); //要设置这个属性，实现 CamelCase -&gt; UnderScore 的转换 properties.put(&quot;hibernate.physical_naming_strategy&quot;, &quot;org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy&quot;); return builder .dataSource(routingDataSource)//关键：注入routingDataSource .properties(properties) .packages(&quot;cn.rzwl.multidata.entity&quot;) //TODO 改成自己的实体类包 .persistenceUnit(&quot;myPersistenceUnit&quot;) .build(); &#125; @Primary @Bean(name = &quot;entityManagerFactory&quot;) public EntityManagerFactory entityManagerFactory(EntityManagerFactoryBuilder builder) &#123; return this.entityManagerFactoryBean(builder).getObject(); &#125; @Primary @Bean(name = &quot;transactionManager&quot;) public PlatformTransactionManager transactionManager(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactory(builder)); &#125;&#125; 为方便测试，用filter验证 1234567891011121314151617181920212223242526272829@WebFilter(urlPatterns = &quot;/*&quot;)@Slf4jpublic class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info(&quot;初始化自定义过滤器&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; String site = request.getParameter(&quot;source&quot;); if( DynamicDataSourceRouter.SourceName.TEST1.dbName.equals( site ) )&#123; DynamicDataSourceRouter.dbStore.set( DynamicDataSourceRouter.SourceName.TEST1.dbName ); &#125; else &#123; DynamicDataSourceRouter.dbStore.set( DynamicDataSourceRouter.SourceName.TEST2.dbName ); &#125; log.info(&quot;进入业务流程&quot;); chain.doFilter( request,response ); log.info(&quot;完成处理&quot;); System.out.println(&quot;后续操作&quot;); &#125; @Override public void destroy() &#123; &#125;&#125; 源码地址: 点击可看 小结： 一个神奇的AbstractRoutingDataSource类，使数据库切换操作举重若轻，优雅得体，告别劳力式编程。","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.rongzhiweilai.com/tags/springboot/"},{"name":"动态切换数据源","slug":"动态切换数据源","permalink":"https://github.rongzhiweilai.com/tags/动态切换数据源/"},{"name":"datasource","slug":"datasource","permalink":"https://github.rongzhiweilai.com/tags/datasource/"}]},{"title":"redis session时，sessionId作为token，可靠实现","slug":"redis-session时，sessionId作为token，可靠实现","date":"2019-04-19T04:06:01.000Z","updated":"2020-07-19T05:10:10.544Z","comments":true,"path":"2019/04/19/redis-session时，sessionId作为token，可靠实现/","link":"","permalink":"https://github.rongzhiweilai.com/2019/04/19/redis-session时，sessionId作为token，可靠实现/","excerpt":"场景：在一些不能使用session，或者session不能保持的情况，通常服务器端产生一个token字符串标识用户登录状态。当前端调用后端接口时，将此token作为参数加入到请求中，这样能够避免依赖浏览器与服务端会话状态。token身份验证可用于多域名间保持用户状态，后端负载均衡非ip hash策略等情况。","text":"场景：在一些不能使用session，或者session不能保持的情况，通常服务器端产生一个token字符串标识用户登录状态。当前端调用后端接口时，将此token作为参数加入到请求中，这样能够避免依赖浏览器与服务端会话状态。token身份验证可用于多域名间保持用户状态，后端负载均衡非ip hash策略等情况。 实现过程： pom中增加redis和session依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在登陆过程中将用户信息和其他需要的信息放入session 12HttpSession httpSession = request.getSession();httpSession.setAttribute(&quot;user&quot;, user); 把sessionId返回给前端 123String sessionId = httpSession.getId();JSONObject result = new JSONObject();result.put(&quot;sessionId&quot;, sessionId); 这样的流程就是经常使用session的方式。 token(sessionId)使用过程 （重点）重点是从session中获取user的过程，在接收到前端请求时，常见获取user的实现代码： 1User user = (User) httpSession.getAttribute(&quot;user&quot;); 但是这样就没有token什么事了，并没有是使用token来做验证。如果要想使用token（sessionId）获取到user，第一个想法就是直接从使用redisTemplate的hash操作，根据key获取到里面的内容，查看一下redis存储session的key，如图： 这里获取还要注意序列化的问题，只有使用相同方式序列化key后才能获取到值。 这种方式想想就很复杂，难道没有简洁的方式获取到这些值吗，存进去的时候挺简单，拿出来时候不能这么麻烦吧。本着对spring强大的信心，寻找到了一个bean：RedisOperationsSessionRepository redisOperationsSessionRepository;看到这个类的名字就很亲切，猜想一定它一定能够解决问题。通过自动注入，然后调用方法，得出以下代码： 12345678Session session=redisOperationsSessionRepository.findById(sessionId);if(session==null)&#123; throw new ForbidException(&quot;请重新登录&quot;);&#125;user=session.getAttribute(&quot;user&quot;);if(user==null)&#123; redisOperationsSessionRepository.deleteById(sessionId);&#125; 注意这里的session是org.springframework.session.Session，而不是javax.servlet.http.HttpSession（常用的那个session），但是两者有着密切关系，通过适配器模式，将javax.servlet.http.HttpSession转为org.springframework.session.Session。 这样就能很方便的通过这个token（sessionId）获取到存储在redis的session的信息。 这里显然RedisOperationsSessionRepository是解决的关键点，至于是如何找到它，有两种方法： 第一种，看spring-session-data-redis和spring-session-core源码，找到关键点，这种方法估计会多花3个小时的时间； 第二种，最简单直接，而且在找到之后再看源码会更清晰，如果感兴趣的话，评论超过5人，我更新文档进行说明，嘎嘎，大神请飘过。 不足之处请指正。","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://github.rongzhiweilai.com/tags/redis/"},{"name":"session","slug":"session","permalink":"https://github.rongzhiweilai.com/tags/session/"},{"name":"token","slug":"token","permalink":"https://github.rongzhiweilai.com/tags/token/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://github.rongzhiweilai.com/tags/适配器模式/"}]},{"title":"post请求响应405，两种解决办法","slug":"post请求响应405，两种解决办法","date":"2019-03-18T14:56:01.000Z","updated":"2020-07-19T05:10:10.544Z","comments":true,"path":"2019/03/18/post请求响应405，两种解决办法/","link":"","permalink":"https://github.rongzhiweilai.com/2019/03/18/post请求响应405，两种解决办法/","excerpt":"问题 为什么会出现405呢，一般是因为在发送POST请求时，请求路径写错，比如后端接口地址是/api/abc/ 而发送请求时的路径为/api/abc 没有了最后的斜线。 这个问题一般通过后端做路径补全解决，如果要求前端每个都严格对上路径格式，那就太难为人了，增加无用工作量。","text":"问题 为什么会出现405呢，一般是因为在发送POST请求时，请求路径写错，比如后端接口地址是/api/abc/ 而发送请求时的路径为/api/abc 没有了最后的斜线。 这个问题一般通过后端做路径补全解决，如果要求前端每个都严格对上路径格式，那就太难为人了，增加无用工作量。 解决办法 服务端解决有两种方法 应用服务器层面，通过应用服务器（如nginx）格式化路径； 应用层面，代码增加过滤器，格式化路径； 具体实现 两种方法的实现 在nginx中可使用rewrite指令，在location中使用if判断uri结尾字符是否为斜杠，若不是，补充斜杠，具体实现代码如下： 123456location /api/&#123; if ($request_filename !~ &quot;/$&quot;) &#123; rewrite ^(/api/.*) $1/$args?; &#125; proxy_pass http://127.0.0.1:8080; &#125; 在应用层（Spring Web实现）增加过滤器，判断uri结尾，需要时补充斜杠，代码如下： 定义过滤器逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package default;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * @author : championjing * @ClassName: UrlFilter * @Description: TODO * @Date: 3/1/2019 5:07 PM */public class UrlFilter implements Filter &#123; private final static Logger LOGGER = LoggerFactory.getLogger(UrlFilter.class); @Override public void init(javax.servlet.FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest)request; //HttpServletResponseWrapper httpResponse = new HttpServletResponseWrapper((HttpServletResponse) response); LOGGER.info(&quot;url:&#123;&#125;&quot;,httpRequest.getRequestURI()); LOGGER.info(&quot;method:&#123;&#125;&quot;,httpRequest.getMethod()); LOGGER.info(&quot;content_type:&#123;&#125;&quot;,httpRequest.getHeader(&quot;content-type&quot;)); LOGGER.info(&quot;cookie:&#123;&#125;&quot;,httpRequest.getHeader(&quot;cookie&quot;)); LOGGER.info(&quot;param:&#123;&#125;&quot;,httpRequest.getQueryString()); String path=httpRequest.getRequestURI(); if(!path.endsWith(&quot;/&quot;))&#123; path=path+&quot;/&quot;; LOGGER.info(&quot;格式化path:&#123;&#125;&quot;,path); httpRequest.getRequestDispatcher(path).forward(request,response); &#125; else &#123; chain.doFilter(request,response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 向Spring容器中加入该过滤器： 12345678910111213141516171819202122232425package default;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author : championjing * @ClassName: FilterConfig * @Description: TODO * @Date: 3/1/2019 5:14 PM */@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean registFilter() &#123; System.out.println(&quot;*******添加过滤器*******&quot;); FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new UrlFilter()); registration.addUrlPatterns(&quot;/wx/*&quot;); registration.setName(&quot;UrlFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 小结 当post一个并不存在接口时，会返回给405的响应，首先要检查路径是否写错，但极有可能是缺少斜杠问题，这种补全逻辑最好在服务端处理，减少前端失误，让我们一起呵护前端的小伙伴吧！","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://github.rongzhiweilai.com/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://github.rongzhiweilai.com/tags/Java/"},{"name":"405","slug":"405","permalink":"https://github.rongzhiweilai.com/tags/405/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.rongzhiweilai.com/tags/Nginx/"}]},{"title":"处理json参数的注解，更方便的获取请求参数","slug":"处理json参数的注解，更方便的获取请求参数","date":"2019-03-07T03:16:22.000Z","updated":"2020-07-19T05:10:10.544Z","comments":true,"path":"2019/03/07/处理json参数的注解，更方便的获取请求参数/","link":"","permalink":"https://github.rongzhiweilai.com/2019/03/07/处理json参数的注解，更方便的获取请求参数/","excerpt":"@JSONParam需求描述当请求的content-type为application/json时实现一下功能： 对请求体中的参数做required判断 解析参数为指定类型 提供默认值","text":"@JSONParam需求描述当请求的content-type为application/json时实现一下功能： 对请求体中的参数做required判断 解析参数为指定类型 提供默认值 为什么做@JSONParam（瞎掰） 自Java5.0版本引入注解之后，各种注解层出不穷。注解的使用让代码简洁优雅，更重要的是，提高代码重用，达到解耦的目的，利于代码的维护和修改。 对于Web后端框架来说，Spring 相关组件提供了大量注解，提高了开发速度，就拿@RequestParam来说，放在接口方法的参数前，通过几个属性，就能减少很多的参数校验和类型转换操作。 但是@RequestParam只应用于content-type为application/x-www-form-urlencoded（传统表单方式）的场景，并不适用application/json情况。这时大多会使用@RequestBody代替@RequestParam来获取一个JSON对象（或其他自定义对象），不过对这个JSON对象中的属性和值仍是无感，所以必须在方法体中对这个JSON对象中的属性进行一系列判断。在写这一系列判断时，真是万分感念@RequestParam的贴心与勤劳。 忍无可忍之下，决定自己动手写一个能够在application/json情况实现@RequestParam类似功能的注解@JSONParam，代码已经提交到github ：https://github.com/championjing/spring-annotation-extension查看具体实现代码 不足之处 每个参数的处理都会请求体中的输入流转为字符串，感觉会有更好的处理方式，但还没想好； 想要的改进 name属性可以接受数组，required、defaultValue也接受数组，并与name对应，当返回值类型为JSON时，对这些内容进行一一判断和赋值操作，可避免上面提到的转字符串问题； 使用方法 在pom中添加maven依赖；12345&lt;dependency&gt; &lt;groupId&gt;com.rongzhiweilai.extension&lt;/groupId&gt; &lt;artifactId&gt;spring-annotation-extension&lt;/artifactId&gt; &lt;version&gt;0.1.0-releases&lt;/version&gt;&lt;/dependency&gt; Tip: 发布时版本号写的略显随意，实例项目中也需要引入该版本 将类WebListenerConfiguration加入Spring容器； 1234567@SpringBootApplication@Import(&#123;com.rongzhiweilai.extension.config.WebListenerConfiguration.class&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 示例项目 点击查看示例项目代码 希望和大家交流意见，或是推荐已有的实现方案","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://github.rongzhiweilai.com/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://github.rongzhiweilai.com/tags/Java/"},{"name":"JSON","slug":"JSON","permalink":"https://github.rongzhiweilai.com/tags/JSON/"},{"name":"注解开发","slug":"注解开发","permalink":"https://github.rongzhiweilai.com/tags/注解开发/"}]},{"title":"精简web框架 理解DI、IOC","slug":"精简web框架-理解DI-IOC","date":"2018-05-15T12:48:27.000Z","updated":"2020-07-19T05:10:10.546Z","comments":true,"path":"2018/05/15/精简web框架-理解DI-IOC/","link":"","permalink":"https://github.rongzhiweilai.com/2018/05/15/精简web框架-理解DI-IOC/","excerpt":"前言话说工欲善其事必先利其器，一个优秀的web框架可以说是程序员的利器，Spring框架应是其中牛角，有了它程序员可以更好的关注业务和功能的实现，编码水平瞬间被提升了一个等级，然而在每天使用框架的时候，你是不是会好奇或者迷惑，为什么它能够运行起来？为什么仅是添加一个注解就能够将一个实例赋值给一个被注解的变量？那些听起来高端的概念（如：IOC、DI、AOP等）是如何实现的呢？","text":"前言话说工欲善其事必先利其器，一个优秀的web框架可以说是程序员的利器，Spring框架应是其中牛角，有了它程序员可以更好的关注业务和功能的实现，编码水平瞬间被提升了一个等级，然而在每天使用框架的时候，你是不是会好奇或者迷惑，为什么它能够运行起来？为什么仅是添加一个注解就能够将一个实例赋值给一个被注解的变量？那些听起来高端的概念（如：IOC、DI、AOP等）是如何实现的呢？ 本文我们将通过实现一个简单的Java Web框架来理解框架的工作原理和IOC等概念的实现，暂且叫它fine。 首先给出Java Web框架开发整个流程: 具体实现 创建一个maven项目实现fine框架 创建mavne项目添加相关依赖，需要的包大致有：servlet、jsp、jstl、log4j、 mysql、json、 等以及一些工具包，如果你不打算使用视图层可以忽略jsp 和jstl的依赖包。 编写加载配置项的工具类ConfigHelper。加一些需要的配置变量。 开发类加载器ClassUtil。在程序启动之初加载基础包下所有类。 编写注解类，比如@Action（接受http请求的方法）, @Inject（依赖注入）等。注解的概念在书《Java编程思想》中介绍的很清楚，是一种标记，本框架中的注解就是为了在运行中框架能够让程序知道被注解的类、方法或者变量有哪些。 实现Bean容器ClassHelper。利用反射机制，将上一步加载的类实例化成对象，并将这些对象放入一个静态的Map&lt;Class&lt;?&gt;,Object&gt;中，此Map就是Bean容器，它记录了类与对象的关系，以后需要单例的对象时就从Bean容器中取出。 实现依赖注入，也就是IoC（控制反转），框架来控制对象之间的依赖关系，将一个对象赋值给一个加了相应标记（注解）的变量。具体实现过程是将第4步中的Bean容器（Map&lt;Class&lt;?&gt;,Object&gt;）做遍历操作，查看当前类的成员变量是否带有Inject注解，若带有该注解，就从Bean容器中取出对象，赋值给当前成员变量。 实现Controller层，通过一个类ControllerHelper统计请求路径与方法的对应关系。通过反射获取带有@Action注解的方法，获取@Action注解中的请求表达式（请求路径信息），封装一个请求对象（Request）与处理对象（Handler），将Request与Handler建立映射关系，处理请求。 实现一个请求转发器，处理所有请求，从HttpServletRequest对象中获取请求路径与参数，将请求路径与ControllerHelper统计的请求路径做对应关系，并将参数传入ControllerHelper中的相应方法。 总结至此，一个能够处理http请求的框架终于开发完成，其中还有很多不足之处，但是通过此框架能够深入的理解现在工程中使用的优秀框架的工作原理，有利于我们更好的在实际中排查问题，甚至定义一些特定规则优化现有框架。 本文参考书籍 《Java编程思想》 《Spring源码解析》 《架构探险 从零开始写javaweb框架》","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.rongzhiweilai.com/tags/Java/"},{"name":"web 框架","slug":"web-框架","permalink":"https://github.rongzhiweilai.com/tags/web-框架/"},{"name":"DI 依赖注入","slug":"DI-依赖注入","permalink":"https://github.rongzhiweilai.com/tags/DI-依赖注入/"},{"name":"IOC 控制反转","slug":"IOC-控制反转","permalink":"https://github.rongzhiweilai.com/tags/IOC-控制反转/"}]},{"title":"探究的官方JSON与阿里的fastjson中put操作","slug":"探究的官方JSON与阿里的fastjson中put操作","date":"2017-06-05T06:55:34.000Z","updated":"2020-07-19T05:10:10.545Z","comments":true,"path":"2017/06/05/探究的官方JSON与阿里的fastjson中put操作/","link":"","permalink":"https://github.rongzhiweilai.com/2017/06/05/探究的官方JSON与阿里的fastjson中put操作/","excerpt":"场景首先看两段代码//======================第一段=============================1234567891011import org.json.JSONObject;public class JSONTest &#123; public static void main(String[] args) &#123; JSONObject json = new JSONObject(); json.put(&quot;key&quot;, &quot;123&quot;); System.out.println(&quot;#1:&quot;+json.toString()); System.out.println(&quot;#2:&quot;+ new JSONObject().put(&quot;key&quot;, &quot;123&quot;).toString() ); &#125;&#125;","text":"场景首先看两段代码//======================第一段=============================1234567891011import org.json.JSONObject;public class JSONTest &#123; public static void main(String[] args) &#123; JSONObject json = new JSONObject(); json.put(&quot;key&quot;, &quot;123&quot;); System.out.println(&quot;#1:&quot;+json.toString()); System.out.println(&quot;#2:&quot;+ new JSONObject().put(&quot;key&quot;, &quot;123&quot;).toString() ); &#125;&#125; //============================第二段=======================123456789101112import com.alibaba.fastjson.JSONObject;public class JSONTest &#123; public static void main(String[] args) &#123; JSONObject json = new JSONObject(); json.put(&quot;key&quot;, &quot;123&quot;); System.out.println(&quot;#1:&quot;+json.toString()); System.out.println(&quot;#2:&quot;+ new JSONObject().put(&quot;key&quot;, &quot;123&quot;).toString() ); &#125;&#125; //=================================================== 很明显的看出这两部分只是引入的jar不同而已。那么运行起来效果能不能一样呢？答案肯定是不同的。首先json.org给出的jar包能够正常运行出你想要的结果，但是fastjson就会给你一些惊喜（自己试一下吧）。为什么会有这种不同呢？ 看看源码一看源码便知。首先json.org实现：public JSONObject put(String key, Object value) throws JSONException { if (key == null) { throw new NullPointerException(“Null key.”); } if (value != null) { testValidity(value); this.map.put(key, value); } else { this.remove(key); } return this;}这里的put函数会将当前实例返回(return this).所以#2处的连续操作始终是当前实例出来的JSONObject的操作，是没有问题的。再看fastjson中put实现方法：public Object put(String key, Object value) { return map.put(key, value);}这里返回了map的put方法返回值，下面给出map的put方法实现： /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) { if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } 当传入的key已经存在时，将返回key对应已有的value，如果key不存在，就会返回null，注释里面说的非常清楚。 总结所以fastjson中的put会依据map中已有的key值来返回不同的值，所以#2中的toString是对key对应的值的操作，但是如果之前key在json中不存在就会变成对null的操作。一点学习经历，不足之处，请多指正。","categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.rongzhiweilai.com/tags/Java/"},{"name":"JSON","slug":"JSON","permalink":"https://github.rongzhiweilai.com/tags/JSON/"},{"name":"fastjson","slug":"fastjson","permalink":"https://github.rongzhiweilai.com/tags/fastjson/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://github.rongzhiweilai.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.rongzhiweilai.com/tags/java/"},{"name":"类加载过程","slug":"类加载过程","permalink":"https://github.rongzhiweilai.com/tags/类加载过程/"},{"name":"Spring","slug":"Spring","permalink":"https://github.rongzhiweilai.com/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.rongzhiweilai.com/tags/设计模式/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://github.rongzhiweilai.com/tags/微信小程序/"},{"name":"appid","slug":"appid","permalink":"https://github.rongzhiweilai.com/tags/appid/"},{"name":"前端","slug":"前端","permalink":"https://github.rongzhiweilai.com/tags/前端/"},{"name":"Flutter","slug":"Flutter","permalink":"https://github.rongzhiweilai.com/tags/Flutter/"},{"name":"源码分析","slug":"源码分析","permalink":"https://github.rongzhiweilai.com/tags/源码分析/"},{"name":"组件","slug":"组件","permalink":"https://github.rongzhiweilai.com/tags/组件/"},{"name":"springboot","slug":"springboot","permalink":"https://github.rongzhiweilai.com/tags/springboot/"},{"name":"动态切换数据源","slug":"动态切换数据源","permalink":"https://github.rongzhiweilai.com/tags/动态切换数据源/"},{"name":"datasource","slug":"datasource","permalink":"https://github.rongzhiweilai.com/tags/datasource/"},{"name":"redis","slug":"redis","permalink":"https://github.rongzhiweilai.com/tags/redis/"},{"name":"session","slug":"session","permalink":"https://github.rongzhiweilai.com/tags/session/"},{"name":"token","slug":"token","permalink":"https://github.rongzhiweilai.com/tags/token/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://github.rongzhiweilai.com/tags/适配器模式/"},{"name":"Java","slug":"Java","permalink":"https://github.rongzhiweilai.com/tags/Java/"},{"name":"405","slug":"405","permalink":"https://github.rongzhiweilai.com/tags/405/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.rongzhiweilai.com/tags/Nginx/"},{"name":"JSON","slug":"JSON","permalink":"https://github.rongzhiweilai.com/tags/JSON/"},{"name":"注解开发","slug":"注解开发","permalink":"https://github.rongzhiweilai.com/tags/注解开发/"},{"name":"web 框架","slug":"web-框架","permalink":"https://github.rongzhiweilai.com/tags/web-框架/"},{"name":"DI 依赖注入","slug":"DI-依赖注入","permalink":"https://github.rongzhiweilai.com/tags/DI-依赖注入/"},{"name":"IOC 控制反转","slug":"IOC-控制反转","permalink":"https://github.rongzhiweilai.com/tags/IOC-控制反转/"},{"name":"fastjson","slug":"fastjson","permalink":"https://github.rongzhiweilai.com/tags/fastjson/"}]}